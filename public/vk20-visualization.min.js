(function (factory) {
  typeof define === 'function' && define.amd ? define(factory) :
  factory();
}((function () { 'use strict';

  /**
   * Starts a fixed timestep update loop.
   * @param {*} updateFn Update callback, will be called multiple times per animation frame.
   * @param {*} renderFn Render callback, will be called only once per animation frame
   */

  function startUpdateLoop(updateFn, renderFn) {
    var lastFrameTimeMs = Date.now();
    var maxFPS = 60;
    var timestep = 1000 / 60;
    var delta = 0;
    var running = true;

    function mainLoop() {
      if (!running) return;
      var timestamp = Date.now(); // Throttle the frame rate

      if (timestamp < lastFrameTimeMs + 1000 / maxFPS) {
        window.requestAnimationFrame(mainLoop);
        return;
      }

      delta += timestamp - lastFrameTimeMs;

      if (delta > timestep * maxFPS) {
        delta = timestep * maxFPS;
      }

      lastFrameTimeMs = timestamp;
      var numUpdateSteps = 0;

      while (delta >= timestep) {
        updateFn(timestep);
        delta -= timestep;

        if (++numUpdateSteps >= 240) {
          delta = 0;
          break;
        }
      }

      renderFn();
      window.requestAnimationFrame(mainLoop);
    }

    window.requestAnimationFrame(mainLoop);
    return function () {
      running = false;
    };
  }
  function lerp(v0, v1, t) {
    return v0 * (1 - t) + v1 * t;
  }
  var multiplier = Math.sqrt(3) / 2;
  function drawEqTriangle(ctx, side, cx, cy) {
    var rotation = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    var h = side * multiplier;
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(rotation * 0.0174533);
    ctx.beginPath();
    ctx.moveTo(0, -h / 2);
    ctx.lineTo(-side / 2, h / 2);
    ctx.lineTo(side / 2, h / 2);
    ctx.lineTo(0, -h / 2);
    ctx.stroke();
    ctx.closePath();
    ctx.restore();
  }
  function shuffle(array) {
    var currentIndex = array.length,
        temporaryValue,
        randomIndex; // While there remain elements to shuffle...

    while (0 !== currentIndex) {
      // Pick a remaining element...
      randomIndex = Math.floor(Math.random() * currentIndex);
      currentIndex -= 1; // And swap it with the current element.

      temporaryValue = array[currentIndex];
      array[currentIndex] = array[randomIndex];
      array[randomIndex] = temporaryValue;
    }

    return array;
  }
  function distanceToRectEdge(rx, ry, rw, rh, px, py) {
    px -= rx;
    py -= ry;
    var left = px;
    var right = rw - px;
    var top = py;
    var bottom = rh - py;
    return Math.min(bottom, Math.min(right, Math.min(top, left)));
  }

  var CANVAS_OPACITY =  1.0;
  var POPULATION_SIZE = 100;
  var CITIZENS_PER_REP = 10;
  var PARTY_MAX_SIZE = 0.4; // Number of opinions that citizens have

  var OPINION_COUNT = 5; // How close to the window edges citizens can spawn

  var PARLIAMENT_RADIUS = 80; // Multiplier for spacing between seats

  var PARLIAMENT_SPACING = 1.2; // Number of clusters

  var MIN_CLUSTERS = 7;
  var MAX_CLUSTERS = 12; // Radius of a citizen

  var CITIZEN_RADIUS = 5; // Let's keep a respectable distance between citizens.

  var CITIZEN_PADDING = 5; // How much bigger an elected official is

  var ELECTED_RADIUS_MULTIPLIER = 1; // Seconds it takes to grow when elected.

  var ELECTION_PROCESS_LENGTH = 0.5; // Seconds between elections

  var SPEED_LIMIT = 0.01;
  var AIR_FRICTION = 0.8; // Number of velocity reading stored for sleep detection.

  var VELOCITY_HISTORY_LENGTH = 10; // Avg velocity over history has to be below this for a citizen to be asleep.

  var STILLNESS_LIMIT = 0.01; // Distance from edge of canvas where fadein happens.

  /*
   * Javascript Quadtree 
   * @version 1.2.1
   * @licence MIT
   * @author Timo Hausmann
   * https://github.com/timohausmann/quadtree-js/
   */

  /*
  Copyright Â© 2012-2020 Timo Hausmann

  Permission is hereby granted, free of charge, to any person obtaining
  a copy of this software and associated documentation files (the
  "Software"), to deal in the Software without restriction, including
  without limitation the rights to use, copy, modify, merge, publish,
  distribute, sublicense, and/or sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to
  the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */

  /*
      * Quadtree Constructor
      * @param Object bounds            bounds of the node { x, y, width, height }
      * @param Integer max_objects      (optional) max objects a node can hold before splitting into 4 subnodes (default: 10)
      * @param Integer max_levels       (optional) total max levels inside root Quadtree (default: 4) 
      * @param Integer level            (optional) deepth level, required for subnodes (default: 0)
      */
  function Quadtree(bounds, max_objects, max_levels, level) {
    this.max_objects = max_objects || 10;
    this.max_levels = max_levels || 4;
    this.level = level || 0;
    this.bounds = bounds;
    this.objects = [];
    this.nodes = [];
  }
  /*
      * Split the node into 4 subnodes
      */

  Quadtree.prototype.split = function () {
    var nextLevel = this.level + 1,
        subWidth = this.bounds.width / 2,
        subHeight = this.bounds.height / 2,
        x = this.bounds.x,
        y = this.bounds.y; //top right node

    this.nodes[0] = new Quadtree({
      x: x + subWidth,
      y: y,
      width: subWidth,
      height: subHeight
    }, this.max_objects, this.max_levels, nextLevel); //top left node

    this.nodes[1] = new Quadtree({
      x: x,
      y: y,
      width: subWidth,
      height: subHeight
    }, this.max_objects, this.max_levels, nextLevel); //bottom left node

    this.nodes[2] = new Quadtree({
      x: x,
      y: y + subHeight,
      width: subWidth,
      height: subHeight
    }, this.max_objects, this.max_levels, nextLevel); //bottom right node

    this.nodes[3] = new Quadtree({
      x: x + subWidth,
      y: y + subHeight,
      width: subWidth,
      height: subHeight
    }, this.max_objects, this.max_levels, nextLevel);
  };
  /*
      * Determine which node the object belongs to
      * @param Object pRect      bounds of the area to be checked, with x, y, width, height
      * @return Array            an array of indexes of the intersecting subnodes 
      *                          (0-3 = top-right, top-left, bottom-left, bottom-right / ne, nw, sw, se)
      */


  Quadtree.prototype.getIndex = function (pRect) {
    var indexes = [],
        verticalMidpoint = this.bounds.x + this.bounds.width / 2,
        horizontalMidpoint = this.bounds.y + this.bounds.height / 2;
    var startIsNorth = pRect.y < horizontalMidpoint,
        startIsWest = pRect.x < verticalMidpoint,
        endIsEast = pRect.x + pRect.width > verticalMidpoint,
        endIsSouth = pRect.y + pRect.height > horizontalMidpoint; //top-right quad

    if (startIsNorth && endIsEast) {
      indexes.push(0);
    } //top-left quad


    if (startIsWest && startIsNorth) {
      indexes.push(1);
    } //bottom-left quad


    if (startIsWest && endIsSouth) {
      indexes.push(2);
    } //bottom-right quad


    if (endIsEast && endIsSouth) {
      indexes.push(3);
    }

    return indexes;
  };
  /*
      * Insert the object into the node. If the node
      * exceeds the capacity, it will split and add all
      * objects to their corresponding subnodes.
      * @param Object pRect        bounds of the object to be added { x, y, width, height }
      */


  Quadtree.prototype.insert = function (pRect) {
    var i = 0,
        indexes; //if we have subnodes, call insert on matching subnodes

    if (this.nodes.length) {
      indexes = this.getIndex(pRect);

      for (i = 0; i < indexes.length; i++) {
        this.nodes[indexes[i]].insert(pRect);
      }

      return;
    } //otherwise, store object here


    this.objects.push(pRect); //max_objects reached

    if (this.objects.length > this.max_objects && this.level < this.max_levels) {
      //split if we don't already have subnodes
      if (!this.nodes.length) {
        this.split();
      } //add all objects to their corresponding subnode


      for (i = 0; i < this.objects.length; i++) {
        indexes = this.getIndex(this.objects[i]);

        for (var k = 0; k < indexes.length; k++) {
          this.nodes[indexes[k]].insert(this.objects[i]);
        }
      } //clean up this node


      this.objects = [];
    }
  };
  /*
      * Return all objects that could collide with the given object
      * @param Object pRect        bounds of the object to be checked { x, y, width, height }
      * @Return Array            array with all detected objects
      */


  Quadtree.prototype.retrieve = function (pRect) {
    var indexes = this.getIndex(pRect),
        returnObjects = this.objects; //if we have subnodes, retrieve their objects

    if (this.nodes.length) {
      for (var i = 0; i < indexes.length; i++) {
        returnObjects = returnObjects.concat(this.nodes[indexes[i]].retrieve(pRect));
      }
    } //remove duplicates


    returnObjects = returnObjects.filter(function (item, index) {
      return returnObjects.indexOf(item) >= index;
    });
    return returnObjects;
  };
  /*
      * Clear the quadtree
      */


  Quadtree.prototype.clear = function () {
    this.objects = [];

    for (var i = 0; i < this.nodes.length; i++) {
      if (this.nodes.length) {
        this.nodes[i].clear();
      }
    }

    this.nodes = [];
  }; //export for commonJS or browser

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  var Vec2 = /*#__PURE__*/function () {
    /**
     * Create a vector.
     * @param {number} x - The x value.
     * @param {number} y - The y value.
     */
    function Vec2() {
      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      _classCallCheck(this, Vec2);

      this.x = x;
      this.y = y;
    }
    /**
     * Get a copy of the vector.
     * @return {Vec2} The copy.
     */


    _createClass(Vec2, [{
      key: "add",

      /**
       * Adds another vector to the vector.
       * @param {Vec2} a - The other vector.
       */
      value: function add(a) {
        this.x += a.x;
        this.y += a.y;
      }
      /**
       * Subtracts another vector from the vector.
       * @param {Vec2} a - The other vector.
       */

    }, {
      key: "sub",
      value: function sub(a) {
        this.x -= a.x;
        this.y -= a.y;
      }
      /**
       * Multiplies the vector by a scalar.
       * @param {number} x - The scalar.
       */

    }, {
      key: "mult",
      value: function mult(x) {
        this.x *= x;
        this.y *= x;
      }
      /**
       * Divides the vector by a scalar.
       * @param {number} x - The scalar.
       */

    }, {
      key: "div",
      value: function div(x) {
        this.x /= x;
        this.y /= x;
      }
      /**
       * Linearry interpolates the vector into the other vector by scalar x.
       * @param {Vec2} other - The other vector.
       * @param {number} x - The scalar.
       */

    }, {
      key: "lerp",
      value: function lerp(other, x) {
        this.x += (other.x - this.x) * x;
        this.y += (other.y - this.y) * x;
      }
      /**
       * Get the distance between the vector and the other vector.
       * Vectors are representing points here.
       * @param {Vec2} other - The other vector.
       * @return {number} The distance between them.
       */

    }, {
      key: "dist",
      value: function dist(other) {
        return new Vec2(this.x - other.x, this.y - other.y).length;
      }
      /**
       * Set the length of the vector.
       * @param {number} l - The new length value.
       */

    }, {
      key: "setMag",
      value: function setMag(l) {
        if (this.length === 0) return;
        this.mult(l / this.length);
      }
      /**
       * Rotate the vector anticlockwise.
       * @param {number} angle - Rotation angle.
       */

    }, {
      key: "rotate",
      value: function rotate(angle) {
        var h = this.heading;
        var v = Vec2.fromAngle(angle + h);
        v.mult(this.length);
        this.x = v.x;
        this.y = v.y;
      } // Static functions:

      /**
       * Add two vectors together.
       * @param {Vec2} a - Vector.
       * @param {Vec2} b - Other vector.
       * @return {Vec2} The sum of the vectors.
       */

    }, {
      key: "toJSObject",

      /**
       * @return {Object} The vector represented in a JS object
       * Ready to be converted into JSON
       */
      value: function toJSObject() {
        var ret = {};
        ret.x = this.x;
        ret.y = this.y;
        return ret;
      }
      /**
       * Creates a Vec2 class from the given object
       * @param {Object} obj The object to create the class from
       * @return {Vec2} The Vec2 object
       */

    }, {
      key: "copy",
      get: function get() {
        return new Vec2(this.x, this.y);
      }
      /**
       * Get the length of the vector.
       * @return {number} The length.
       */

    }, {
      key: "length",
      get: function get() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }
      /**
       * Get the length of the vector squared.
       * @return {number} The length squared.
       */

    }, {
      key: "sqlength",
      get: function get() {
        return this.x * this.x + this.y * this.y;
      }
      /**
       * Get the heading of the vector compared to (1, 0).
       * @return {number} The angle between (1, 0)
       * and the vector in anticlockwise direction.
       */

    }, {
      key: "heading",
      get: function get() {
        if (this.x === 0 && this.y === 0) return 0;
        if (this.x === 0) return this.y > 0 ? Math.PI / 2 : 1.5 * Math.PI;
        if (this.y === 0) return this.x > 0 ? 0 : Math.PI;
        var v = Vec2.normalized(this);
        if (this.x > 0 && this.y > 0) return Math.asin(v.y);
        if (this.x < 0 && this.y > 0) return Math.asin(-v.x) + Math.PI / 2;
        if (this.x < 0 && this.y < 0) return Math.asin(-v.y) + Math.PI;
        if (this.x > 0 && this.y < 0) return Math.asin(v.x) + 1.5 * Math.PI;
        return 0;
      }
    }], [{
      key: "add",
      value: function add(a, b, vec) {
        if (!vec) vec = new Vec2();
        vec.x = a.x + b.x;
        vec.y = a.y + b.y;
        return vec;
      }
      /**
       * Subtracts one vector from another.
       * @param {Vec2} a - Vector.
       * @param {Vec2} b - Other vector.
       * @return {Vec2} The subtraction of the vectors.
       */

    }, {
      key: "sub",
      value: function sub(a, b, vec) {
        if (!vec) vec = new Vec2();
        vec.x = a.x - b.x;
        vec.y = a.y - b.y;
        return vec;
      }
      /**
       * Multiply the vector by a scalar.
       * @param {Vec2} v - Vector.
       * @param {number} x - Scalar.
       * @return {Vec2} The multiplied vector.
       */

    }, {
      key: "mult",
      value: function mult(v, x, vec) {
        if (!vec) vec = new Vec2();
        vec.x = v.x * x;
        vec.y = v.y * x;
        return vec;
      }
      /**
       * Divide the vector by a scalar.
       * @param {Vec2} v - Vector.
       * @param {number} x - Scalar.
       * @return {Vec2} The divided vector.
       */

    }, {
      key: "div",
      value: function div(v, x, vec) {
        if (!vec) vec = new Vec2();
        vec.x = v.x / x;
        vec.y = v.y / x;
        return vec;
      }
      /**
       * Create a unit vector from an angle.
       * @param {number} a - The angle.
       * @return {Vec2} The created vector.
       */

    }, {
      key: "fromAngle",
      value: function fromAngle(a) {
        return new Vec2(Math.cos(a), Math.sin(a));
      }
      /**
       * Linearry interpolates a vector into another vector by scalar x.
       * @param {Vec2} a - A vector.
       * @param {Vec2} b - Other vector.
       * @param {number} x - The scalar.
       * @return {Vec2} The created vector.
       */

    }, {
      key: "lerp",
      value: function lerp(a, b, x) {
        return Vec2.add(a, Vec2.mult(Vec2.sub(b, a), x));
      }
      /**
       * Get the distance between vectors.
       * @param {Vec2} a - A vector.
       * @param {Vec2} b - Other vector
       * @return {number} The distance between them.
       */

    }, {
      key: "dist",
      value: function dist(a, b) {
        return Vec2.sub(a, b).length;
      }
      /**
       * Get the dot product of two vectors.
       * @param {Vec2} a - A vector.
       * @param {Vec2} b - Other vector
       * @return {number} The dot product of them.
       */

    }, {
      key: "dot",
      value: function dot(a, b) {
        return a.x * b.x + a.y * b.y;
      }
      /**
       * Get the cross product of two vectors.
       * @param {Vec2} a - A vector.
       * @param {Vec2} b - Other vector
       * @return {number} The cross product of them.
       */

    }, {
      key: "cross",
      value: function cross(a, b) {
        return a.x * b.y - a.y * b.x;
      }
      /**
       * Get the angle between two vectors.
       * @param {Vec2} a - A vector.
       * @param {Vec2} b - Other vector
       * @return {number} Angle between them.
       */

    }, {
      key: "angle",
      value: function angle(a, b) {
        return Math.acos(Vec2.dot(a, b) / Math.sqrt(a.sqlength * b.sqlength));
      }
      /**
       * Get the angle between two vectors but in the anticlockwise direction.
       * @param {Vec2} a - A vector.
       * @param {Vec2} b - Other vector
       * @return {number} Angle between them.
       */

    }, {
      key: "angleACW",
      value: function angleACW(a, b) {
        var ah = a.heading;
        var bh = b.heading;
        var angle = bh - ah;
        return angle < 0 ? 2 * Math.PI + angle : angle;
      }
      /**
       * Get a vector with the same heading with the input vector
       * but with length = 1.
       * @param {Vec2} v - A vector.
       * @return {Vec2} Vector with length = 0.
       */

    }, {
      key: "normalized",
      value: function normalized(v) {
        var l = v.length;
        return l === 0 ? v : new Vec2(v.x / l, v.y / l);
      }
    }, {
      key: "fromObject",
      value: function fromObject(obj) {
        return new Vec2(obj.x, obj.y);
      }
    }]);

    return Vec2;
  }();
  Vec2.cached = [new Vec2(), new Vec2(), new Vec2(), new Vec2(), new Vec2(), new Vec2(), new Vec2(), new Vec2(), new Vec2(), new Vec2()];

  var STATE_NORMAL = 0;
  var STATE_BEING_ELECTED = 1;
  var STATE_ELECTED = 2;

  var Citizen = /*#__PURE__*/function () {
    function Citizen(opinions, clusterId, scale, cluster) {
      _classCallCheck(this, Citizen);

      this.state = STATE_NORMAL;
      this.position = new Vec2();
      this.prevPosition = this.position.copy;
      this.velocity = new Vec2();
      this.opinions = opinions;
      this.clusterId = clusterId;
      this.radius = 5 * scale;
      this.scale = scale;
      this.k = 0.5;
      this.velocities = [];
      this.cluster = cluster;
      this.randomClusterOffset();
      this.isAtRest = false;
      this.secondsAtRest = 0;
      this.sleepCounter = 0;
      this.opacity = 0;
      this.targetOpacity = 0;
    }

    _createClass(Citizen, [{
      key: "randomClusterOffset",
      value: function randomClusterOffset() {
        var x = this.cluster.radius * 2;
        var y = this.cluster.radius;
        this.clusterOffset = new Vec2(-(x / 2) + Math.random() * x, -(y / 2) + Math.random() * y);
      }
    }, {
      key: "isNormal",
      value: function isNormal() {
        return this.state === STATE_NORMAL;
      }
    }, {
      key: "update",
      value: function update(simulation, dt) {
        var cluster = simulation.clusters[this.clusterId];
        var movement = this.velocity.length; //this.velocities.push(this.velocity.length);

        this.velocities.push(movement);

        if (this.velocities.length > VELOCITY_HISTORY_LENGTH) {
          this.velocities.splice(0, this.velocities.length - VELOCITY_HISTORY_LENGTH);
        }

        this.activityLevel = this.velocities.reduce(function (avg, curr) {
          return avg + curr;
        }, 0) / this.velocities.length;
        var isAtRest = this.activityLevel < STILLNESS_LIMIT;

        if (isAtRest) {
          this.secondsAtRest += dt / 1000;
        } else {
          this.secondsAtRest = 0;
        }

        this.isAtRest = this.secondsAtRest > 2;
        var sleepCountThresh = 5;

        if (movement < 0.005) {
          if (this.sleepCounter < sleepCountThresh) this.sleepCounter++;
        } else {
          if (this.sleepCounter > 0) this.sleepCounter--;
        }

        this.opacity = lerp(this.opacity, this.targetOpacity, 0.1);
        this.isSleeping = this.sleepCounter == sleepCountThresh;
        this.prevPosition = this.position.copy;

        if (this.velocity.sqlength > SPEED_LIMIT * SPEED_LIMIT) {
          this.velocity.setMag(SPEED_LIMIT);
        }

        if (!this.isSleeping) {
          this.position.add(Vec2.mult(this.velocity, dt, Vec2.cached[0]));
        } //this.velocity = new Vec2();


        this.velocity.mult(AIR_FRICTION);

        switch (this.state) {
          case STATE_NORMAL:
            this.updateNormal(simulation, dt);
            break;

          case STATE_BEING_ELECTED:
            this.updateBeingElected(simulation, dt);
            break;

          case STATE_ELECTED:
            this.updateElected(simulation, dt);
            break;
        }
      }
    }, {
      key: "updateNormal",
      value: function updateNormal(simulation, dt) {
        var cluster = simulation.clusters[this.clusterId];

        var diff = Vec2.sub(Vec2.add(this.position, this.clusterOffset, Vec2.cached[0]), new Vec2(cluster.x, cluster.y), Vec2.cached[0]);
        var dist = diff.length;
        this.velocity.sub(new Vec2(diff.x * 0.0000015 * (dist > cluster.radius ? 1.0 : dist / cluster.radius) * dt, diff.y * 0.0000015 * (dist > cluster.radius ? 1.0 : dist / cluster.radius) * dt));
        this.mass = 1 + dist;

        if (Math.random() < 0.00005) {
          this.randomClusterOffset();
        }
      }
    }, {
      key: "updateBeingElected",
      value: function updateBeingElected(simulation, dt) {
        this.electionTimer += dt / 1000;
        var cluster = simulation.clusters[this.clusterId];
        /*
        this.radius = lerp( CITIZEN_RADIUS, 
                            CITIZEN_RADIUS * ELECTED_RADIUS_MULTIPLIER, 
                            this.electionTimer / ELECTION_PROCESS_LENGTH
                            ) * this.scale
                            */

        if (this.electionTimer >= ELECTION_PROCESS_LENGTH) {
          //this.radius = CITIZEN_RADIUS * ELECTED_RADIUS_MULTIPLIER  * this.scale;
          this.state = STATE_ELECTED;
          cluster.beingElectedCount--;
        }
      }
    }, {
      key: "updateElected",
      value: function updateElected(simulation, dt) {
        var parliament = simulation.parliament;
        var dir = Vec2.sub(this.seat, this.position);
        var dist = dir.length;

        if (dist < 5) {
          this.mass = 1;
        } else {
          this.mass = 10000;
        }

        if (dist > 3) {
          dir.setMag(1);
          dir.mult(0.1 * dt / 1000);
          this.velocity.add(dir);
        }
      }
    }], [{
      key: "getElectedFullRadius",
      value: function getElectedFullRadius() {
        return CITIZEN_RADIUS * ELECTED_RADIUS_MULTIPLIER + CITIZEN_PADDING;
      }
    }, {
      key: "collide",
      value: function collide(citizenA, citizenB) {
        var radius = citizenA.radius + citizenB.radius + CITIZEN_PADDING * citizenA.scale;
        if (Math.abs(citizenA.position.x - citizenB.position.x) > radius && Math.abs(citizenA.position.y - citizenB.position.y) > radius) return;
        var diff = Vec2.sub(citizenA.position, citizenB.position, Vec2.cached[0]);
        var distSqrt = diff.sqlength;
        if (distSqrt > radius * radius) return false;
        var m1 = citizenA.mass;
        var m2 = citizenB.mass;
        var im1 = 1 / citizenA.mass;
        var im2 = 1 / citizenB.mass;
        var k = (citizenA.k + citizenB.k) / 2;
        var dist = Math.sqrt(distSqrt);
        var overlap = radius - dist;
        diff.setMag(1);
        diff.mult(overlap * m2 / (m1 + m2));
        citizenA.position.add(diff);
        diff.setMag(1);
        diff.mult(-overlap * m1 / (m1 + m2));
        citizenB.position.add(diff);
        var vdot = Vec2.dot(diff, Vec2.sub(citizenA.velocity, citizenB.velocity, Vec2.cached[1]));
        if (vdot < 0) return;
        diff.setMag(1);
        var i = -(1.0 + k) * vdot / (im1 + im2);
        var impulse = Vec2.mult(diff, i, Vec2.cached[2]);
        citizenA.velocity.add(Vec2.mult(impulse, im1, Vec2.cached[3]));
        citizenB.velocity.sub(Vec2.mult(impulse, im2, Vec2.cached[4]));
      }
    }]);

    return Citizen;
  }();

  function sortIntoClusters(opinions, clusterCount) {
    var indecies = [];
    var counts = [];

    for (var i = 0; i < clusterCount; i++) {
      indecies.push(i);
      counts.push(0);
    }

    shuffle(indecies);
    var results = [];
    var total = 1;
    var maxPercentage = Math.max(PARTY_MAX_SIZE, total / clusterCount);

    for (var i = 0; i < clusterCount; i++) {
      var per = total * Math.random();
      if (per > maxPercentage) per = maxPercentage;
      total -= per;
      counts[indecies[i]] = per;
    }

    var ix = 0;

    for (var i = 0; i < clusterCount; i++) {
      var percentage = counts[i];
      results.push(opinions.slice(ix, Math.round(opinions.length * percentage)));
    }

    return results;
  }

  function initSimulation (canvas, centerOn, width, height) {
    var scale = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
    var ctx = canvas.getContext('2d');
    var citizens = [];
    var allOpinions = [];

    for (var i = 0; i < POPULATION_SIZE; i++) {
      var opinions = [];

      for (var j = 0; j < OPINION_COUNT; j++) {
        opinions.push(-1 + Math.random() * 2);
      }

      allOpinions.push(opinions);
    }

    var parliament = {
      position: new Vec2(width / 2, height / 2),
      radius: PARLIAMENT_RADIUS * scale
    };

    if (centerOn) {
      var bb = centerOn.getBoundingClientRect();
      parliament.position.x = bb.x + bb.width / 2;
      parliament.position.y = window.scrollY + bb.y + bb.height / 2 + parliament.radius;
    }

    var clusters = [];
    var clusterCount = MIN_CLUSTERS + Math.round(Math.random() * (MAX_CLUSTERS - MIN_CLUSTERS));
    var clusterPositionRadius = width;
    var clusterCircleCenter = new Vec2(width / 2, parliament.position.y / 2 + clusterPositionRadius);

    if (centerOn) {
      var _bb = centerOn.getBoundingClientRect();

      clusterCircleCenter.y = (window.scrollY + _bb.y) / 2 + clusterPositionRadius;
    }

    var res = sortIntoClusters(allOpinions, clusterCount);
    var minAngle = -180;
    var maxAngle = 0; // Calculate min + max angles, if t

    if (width < clusterPositionRadius * 2) {
      var left = new Vec2(0, clusterCircleCenter.y - Math.sqrt(clusterPositionRadius * clusterPositionRadius - Math.pow(clusterCircleCenter.x - 0, 2)));
      var right = new Vec2(width, clusterCircleCenter.y - Math.sqrt(clusterPositionRadius * clusterPositionRadius - Math.pow(clusterCircleCenter.x - width, 2)));
      var dirL = Vec2.sub(clusterCircleCenter, left);
      var dirR = Vec2.sub(clusterCircleCenter, right);
      minAngle = dirL.heading * 57.2958 - 180;
      maxAngle = dirR.heading * 57.2958 - 180;
    }

    var range = maxAngle - minAngle;
    var spacing = range / (clusterCount + 1);
    var seatsGiven = 0;

    for (var i = 0; i < res.length; i++) {
      var citizenArea = Math.PI * Math.pow(CITIZEN_RADIUS + CITIZEN_PADDING * scale, 2);
      var cluster = {
        opinions: res[i],
        citizenCount: res[i].length,
        representativeCount: 0,
        beingElectedCount: 0,
        timeSinceElection: 0,
        restCount: 0,
        representativeMaxCount: Math.round(res[i].length / CITIZENS_PER_REP),
        x: clusterCircleCenter.x + Math.cos((minAngle + (spacing + i * spacing)) * Math.PI / 180) * clusterPositionRadius + (-(width / 2) + Math.random() * width),
        y: clusterCircleCenter.y + Math.sin((minAngle + (spacing + i * spacing)) * Math.PI / 180) * clusterPositionRadius + (-(height / 2) + Math.random() * height),
        finalX: clusterCircleCenter.x + Math.cos((minAngle + (spacing + i * spacing)) * Math.PI / 180) * clusterPositionRadius,
        finalY: clusterCircleCenter.y + Math.sin((minAngle + (spacing + i * spacing)) * Math.PI / 180) * clusterPositionRadius,
        // Radius calculated based on the circle packing constant.
        radius: Math.sqrt(citizenArea * res[i].length * 0.9069) / Math.PI * 2
      };

      {
        cluster.x = width * Math.random();
        cluster.y = height * Math.random();
        cluster.finalX = width * Math.random();
        cluster.finalY = height * Math.random();
      }

      seatsGiven += cluster.representativeMaxCount;
      clusters.push(cluster);
    } // If too few seats were given, we give the remaining to the last cluster.


    if (seatsGiven < res.length) {
      clusters[clusters.length - 1].representativeMaxCount += res.length - seatsGiven;
    }

    for (var i = 0; i < clusters.length; i++) {
      var _cluster = clusters[i];

      for (var j = 0; j < _cluster.opinions.length; j++) {
        var citizen = new Citizen(_cluster.opinions[j], i, scale, _cluster);
        citizen.position.x = -width + Math.random() * (width * 3);
        citizen.position.y = -height + Math.random() * (height * 3);
        //citizen.position.y = clusters[i].y + Math.sin(ang) * (Math.random() * height / 2);

        citizen.index = citizens.length;
        citizens.push(citizen);
      }
    }

    var simulation = {
      citizens: citizens,
      clusters: clusters,
      parliament: parliament,
      clusterPositionRadius: clusterPositionRadius,
      clusterCircleCenter: clusterCircleCenter,
      width: width,
      height: height
    };
    simulation.parliament.seats = createSeatingOrder(simulation);
    var ix = 0;

    for (var i = 0; i < clusters.length; i++) {
      var _cluster2 = clusters[i];
      _cluster2.seats = simulation.parliament.seats.slice(ix, ix + _cluster2.representativeMaxCount);
      ix += _cluster2.representativeMaxCount;
    }

    var stopUpdate = startUpdateLoop(function (dt) {
      return update(simulation, dt);
    }, function () {
      return render(canvas, ctx, simulation);
    });
    return function () {
      stopUpdate();
    };
  }

  function update(simulation, dt) {
    var citizens = simulation.citizens,
        clusters = simulation.clusters,
        width = simulation.width,
        height = simulation.height;
    var quadTree = new Quadtree({
      x: -width,
      y: -height,
      width: width * 3,
      height: height * 3
    }, 20, 10);

    for (var i = 0; i < citizens.length; i++) {
      var citizen = citizens[i];
      var cluster = clusters[citizen.clusterId];
      citizen.closeToOthers = 0;
      citizen.update(simulation, dt);
      quadTree.insert({
        x: citizen.position.x - citizen.radius,
        y: citizen.position.y - citizen.radius,
        width: citizen.radius * 2,
        height: citizen.radius * 2,
        citizen: citizen
      });
    }

    for (var i = 0; i < clusters.length; i++) {
      clusters[i].restCount = 0;
      clusters[i].timeSinceElection += dt / 1000;
      clusters[i].x = lerp(clusters[i].x, clusters[i].finalX, 0.0007);
      clusters[i].y = lerp(clusters[i].y, clusters[i].finalY, 0.0007);
    }

    for (var i = 0; i < citizens.length; i++) {
      var _citizen = citizens[i];
      var elements = quadTree.retrieve({
        x: _citizen.position.x - _citizen.radius * 2,
        y: _citizen.position.y - _citizen.radius * 2,
        width: _citizen.radius * 4,
        height: _citizen.radius * 4
      });

      for (var j = 0; j < elements.length; j++) {
        var other = elements[j].citizen;

        if (other != _citizen && other.index > i) {
          Citizen.collide(_citizen, other);
        }

        if (other.clusterId == _citizen.clusterId) {
          _citizen.closeToOthers++;
          other.closeToOthers++;
        }
      }

      if (_citizen.isAtRest) {
        if (_citizen.isNormal()) clusters[_citizen.clusterId].restCount++;
      }

      _citizen.targetOpacity = Math.min(_citizen.closeToOthers, 50) / 50;
    }
  }

  function render(canvas, ctx, simulation) {
    var citizens = simulation.citizens,
        clusters = simulation.clusters,
        parliament = simulation.parliament,
        clusterPositionRadius = simulation.clusterPositionRadius,
        clusterCircleCenter = simulation.clusterCircleCenter,
        width = simulation.width,
        height = simulation.height;
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    ctx.lineWidth = 2;
    citizens.forEach(function (citizen) {
      var position = citizen.position,
          clusterId = citizen.clusterId,
          radius = citizen.radius,
          col = citizen.col;
      var distToEdge = distanceToRectEdge(0, 0, width, height, position.x, position.y);
      if (distToEdge < 0) distToEdge = 0;

      if (citizen.isNormal()) {
        var _canvas = getCachedCanvasImg(clusterId, radius);

        ctx.save();

        ctx.drawImage(_canvas, position.x - _canvas.width / 2, position.y - _canvas.height / 2);
        ctx.restore();
      } else {
        ctx.save();
        ctx.translate(position.x, position.y);
        drawCitizenInCtx(clusterId, radius, ctx, 0);
        ctx.restore();
      }
    });
  }

  var imgCache = {};

  function getCachedCanvasImg(clusterId, radius) {
    if (!imgCache[clusterId]) {
      var offscreen = document.createElement('canvas');
      offscreen.width = radius * 3;
      offscreen.height = radius * 3;
      var ctx = offscreen.getContext('2d');
      ctx.lineWidth = 2;
      drawCitizenInCtx(clusterId, radius, ctx, radius * 3 / 2);
      imgCache[clusterId] = offscreen;
    }

    return imgCache[clusterId];
  }

  function drawCitizenInCtx(clusterId, radius, ctx, offset) {
    ctx.beginPath();

    switch (clusterId + ( 1000 )) {
      case 1:
        {
          // Diamond / Box
          var size = radius;
          ctx.save();
          ctx.translate(offset, offset); //ctx.rotate(45 * 0.0174533);

          ctx.moveTo(-size, -size);
          ctx.lineTo(-size, +size);
          ctx.lineTo(+size, +size);
          ctx.lineTo(+size, -size);
          ctx.lineTo(-size, -size); // An extra line is needed to make the corner of the square nice.

          ctx.lineTo(-size, +size);
          ctx.restore();
        }
        break;

      case 2:
        {
          // Triangle
          drawEqTriangle(ctx, radius * 2.5, offset, offset);
        }
        break;

      case 3:
        {
          // Plus
          var _size = radius + 2;

          var width = _size / 3;
          ctx.save();
          ctx.translate(offset, offset);
          ctx.rotate(45 * 0.0174533);
          ctx.moveTo(-_size, +width);
          ctx.lineTo(-_size, -width);
          ctx.lineTo(-width, -width);
          ctx.lineTo(-width, -_size);
          ctx.lineTo(+width, -_size);
          ctx.lineTo(+width, -width);
          ctx.lineTo(+_size, -width);
          ctx.lineTo(+_size, +width);
          ctx.lineTo(+width, +width);
          ctx.lineTo(+width, +_size);
          ctx.lineTo(-width, +_size);
          ctx.lineTo(-width, +width);
          ctx.lineTo(-_size, +width);
          ctx.lineTo(-_size, -width);
          ctx.restore();
        }
        break;

      case 4:
        {
          ctx.beginPath();

          for (var i = 0; i < Math.PI * 2; i += Math.PI * 2 / 5) {
            var x = offset + Math.cos(i - 90 * Math.PI / 180) * radius * 1.3;
            var y = offset + Math.sin(i - 90 * Math.PI / 180) * radius * 1.3;

            if (i == 0) {
              ctx.moveTo(x, y);
            } else {
              ctx.lineTo(x, y);
            }
          }

          ctx.closePath();
          break;
        }

      case 5:
        {
          // Diamond / Box
          var _size2 = radius;
          ctx.save();
          ctx.translate(offset, offset);
          ctx.rotate(45 * 0.0174533);
          ctx.moveTo(-_size2, -_size2);
          ctx.lineTo(-_size2, +_size2);
          ctx.lineTo(+_size2, +_size2);
          ctx.lineTo(+_size2, -_size2);
          ctx.lineTo(-_size2, -_size2); // An extra line is needed to make the corner of the square nice.

          ctx.lineTo(-_size2, +_size2);
          ctx.restore();
        }
        break;

      case 6:
        {
          // Plus
          var _size3 = radius + 2;

          var _width = _size3 / 3;

          ctx.save();
          ctx.translate(offset, offset);
          ctx.moveTo(-_size3, +_width);
          ctx.lineTo(-_size3, -_width);
          ctx.lineTo(-_width, -_width);
          ctx.lineTo(-_width, -_size3);
          ctx.lineTo(+_width, -_size3);
          ctx.lineTo(+_width, -_width);
          ctx.lineTo(+_size3, -_width);
          ctx.lineTo(+_size3, +_width);
          ctx.lineTo(+_width, +_width);
          ctx.lineTo(+_width, +_size3);
          ctx.lineTo(-_width, +_size3);
          ctx.lineTo(-_width, +_width);
          ctx.lineTo(-_size3, +_width);
          ctx.lineTo(-_size3, -_width);
          ctx.restore();
        }
        break;

      case 7:
        {
          // Triangle
          drawEqTriangle(ctx, radius * 2.5, offset, offset, 180);
        }
        break;

      default:
        // Circle
        ctx.arc(offset, offset, radius, 0, 2 * Math.PI);
        break;
    } //ctx.fillStyle = citizen.isSleeping ? 'orange' : 'black'

    /*if (citizen.isAtRest) {
        ctx.fillStyle = citizen.secondsAtRest > 5 ? 'gold' : "black"
    }*/


     ctx.fill() ;
  }

  function createSeatingOrder(simulation) {
    var parliament = simulation.parliament;
    var electedRadius = Citizen.getElectedFullRadius();
    var targetSeatCount = Math.round(POPULATION_SIZE / CITIZENS_PER_REP);
    var seatPositions = [];
    var level = 0;
    var seats = 0;
    var levelRadius = parliament.radius;

    while (true) {
      if (level > 10) break;
      var minAngle = -170;
      var maxAngle = -10;
      var angleDiff = maxAngle - minAngle;
      var angleSpacing = electedRadius * 2 * PARLIAMENT_SPACING / (Math.PI * levelRadius) * 180;
      var seatCount = Math.round(angleDiff / angleSpacing);
      var trueSpacing = angleDiff / seatCount;

      if (seats + seatCount > targetSeatCount) {
        var diff = targetSeatCount - (seats + seatCount);
        minAngle -= Math.round(diff / 2) * trueSpacing;
      }

      for (var i = 0; i < seatCount + 1; i++) {
        if (seats > targetSeatCount) break;
        seats++;
        var angle = minAngle + i * trueSpacing;
        var x = levelRadius * Math.cos(angle * Math.PI / 180);
        var y = levelRadius * Math.sin(angle * Math.PI / 180);
        seatPositions.push(new Vec2(parliament.position.x + x, parliament.position.y + y));
      }

      if (seats > targetSeatCount) break;
      level++;
      levelRadius += electedRadius * 2 * PARLIAMENT_SPACING;
    }

    seatPositions.sort(function (a, b) {
      var diff = Vec2.sub(a, parliament.position);
      var aDist = diff.length;
      diff.setMag(1);
      var angleA = diff.heading * 57.2958;
      diff = Vec2.sub(b, parliament.position);
      var bDist = diff.length;
      diff.setMag(1);
      var angleB = diff.heading * 57.2958;
      var angleDiff = angleA - angleB;

      if (Math.abs(angleDiff) < 10) {
        return aDist - bDist;
      } else {
        return angleDiff;
      }
    });
    return seatPositions;
  }

  window.initParliamentVisualization = function initParliamentVisualization(_ref) {
    var centerElement = _ref.centerElement,
        _ref$zIndex = _ref.zIndex,
        zIndex = _ref$zIndex === void 0 ? 0 : _ref$zIndex,
        _ref$height = _ref.height,
        height = _ref$height === void 0 ? null : _ref$height,
        _ref$scale = _ref.scale,
        scale = _ref$scale === void 0 ? 1 : _ref$scale;

    if (!centerElement) {
      throw new Error("[initParliamentVisualization] Invalid argument centerElement: ".concat(centerElement));
    }

    var canvas = document.createElement('canvas');
    document.body.prepend(canvas);
    canvas.style = "\n    pointer-events: none; \n    margin: 0; \n    padding: 0; \n    width: 100%; \n    position: absolute;\n    z-index: ".concat(zIndex, "; \n    opacity: ").concat(CANVAS_OPACITY, ";\n    ");
    handleOnResize();

    var start = function start() {
      return initSimulation(canvas, centerElement, window.innerWidth, height || window.innerHeight, scale);
    };

    var stop = start(); // Handle window resizing.

    var warmup = 2;
    var resizeTimeout = null;

    function handleOnResize() {
      canvas.setAttribute('width', window.innerWidth);
      canvas.setAttribute('height', height || window.innerHeight);

      if (warmup <= 0) {
        if (resizeTimeout) {
          clearTimeout(resizeTimeout);
        }

        resizeTimeout = setTimeout(function () {
          stop();
          stop = start();
        }, 200);
      } else {
        warmup--;
      }
    }

    window.onresize = handleOnResize;
    window.addEventListener('resize', handleOnResize);
    return {
      canvas: canvas,
      destroy: function destroy() {
        stop();
        canvas.parentNode.removeChild(canvas);
        window.removeEventListener('resize', handleOnResize);
      }
    };
  };

})));
